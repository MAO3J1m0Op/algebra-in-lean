import Mathlib.Tactic

namespace Sheet2

-- ## Things we want to include in this Sheet2

-- - _Modular arithmetic interlude!_


#check Nat.gcd
#print Nat.gcd

-- The _greatest common denominator_ function takes in two natural numbers and
-- outputs the largest natural number that will divide both inputs.
-- Particularly, the gcd of any number and 0 is the number itself.

#eval gcd 1 2
#eval gcd 100 45
#eval gcd 73 0

-- Similarly, we define the _least common multiple_. It is a function which takes in two natural numbers and outputs the minimal natural number that is divisible by both inputs. The lcm of any number and 9 is 0, since 0 divided by any number is 0.

#check Nat.lcm
#print Nat.lcm

#eval lcm 1 2
#eval lcm 100 45
#eval lcm 73 0

-- Note that the definition for lcm uses the gcd.

-- Efficiently computing the gcd is a seemingly mundane, boring problem, but
-- its implications quite literally form the backbone of the internet as we
-- know it today.

-- The "naive" way to do it is through _prime factorization_; break up each of
-- the numbers into their constituent, atomic parts, and then find the largest
-- part they have in common. But this brute-force algorithm scales very poorly
-- for large numbers. If you find an efficient way to do this, you will also be
-- compromising some of the most important crytography schemes to ever be
-- realized, for example RSA cryptography.

-- Thankfully, there is a quicker way to find the gcd (and therefore lcm) via the Euclidean Algorithm.

-- To introduce the Euclidean Algorithm, first we have to cover modular
-- arithmetic. Basic number theory might seem completely separate from abstract
-- algebra at first, but it shows up increasingly in areas like ring theory, so
-- bear with us.

/- ... -/

-- Examples of group homomorphisms & isomorphisms
-- - Z/nZ is isomorphic to C‚Çô
-- - Any two cyclic groups of the same order are isomorphic

-- Definition of automorphism, (and hence endomorphism?)
-- Mention familiar examples (not formalized): linear transformations between
-- vector spaces, functions (like graphs you see in high school math),
-- permutations

-- Conjugation is an automorphism
-- Which segues us very nicely into the next sheet, which probably will be
-- about automorphism groups

/- ---------- -/

-- ## Homomorphisms and Isomorphisms

-- Like many other things in abstract algebra, you will find that you have seen
-- homomorphisms before, even if you weren't aware that they _were_
-- homomorphisms. For example, the determinant of an n √ó n Real matrix is a
-- homomorphism from the group GL_n(‚Ñù) to (‚Ñù, *).

-- Below, we provide other examples of homomorphisms and isomorphisms with
-- concrete examples of groups that you have already seen before in Chapter 1.

-- We formally introduce the notion of a cyclic group. You have seen this in
-- the previous chapter, as the group of rotational symmetries of an n-gon.

-- Let's look at it through a different lens. C‚ÇÉ is "the cyclic group of order
-- 3". A cyclic group is one that is generated by a single element. In effect,
-- it is the group you get by applying a non-identity element, say g, to
-- itself. For example, the elements of the cyclic group of order 4 can be
-- written {ùïñ, g, g¬≤, g¬≥}. Note that we can write the element ùïñ as g‚Å∞. g is
-- then referred to as the "generator" of the group, and the group generated by
-- an element g can be written <g>. You'll learn more about generators in
-- Chapter 2.

-- We'll use the definition of Cn that you've seen in Chapter 1. Hopefully,
-- you've already proved that it is a group, so we're good to go.

def Cn (n : ‚Ñï): Type := Fin n
def fCn (n : ‚Ñï) : (Cn n) ‚Üí (Cn n) ‚Üí (Cn n) := Fin.add

-- We introduce a closely related group; the integers _modulo_ some natural
-- number n. We write this as ‚Ñ§/n‚Ñ§, for reasons that will become apparent when
-- you eventually come across "quotient groups". We pronounce ‚Ñ§/n‚Ñ§ as "Z mod n
-- Z".

variable (G : ZMod n) (generators : Finset (ZMod n))

#check (ZMod 4 : Type)
#print ZMod

def ZModnZ (n : ‚Ñï) : Type := ZMod n

-- def x : (ZModnZ 3) := 2

#print ZModnZ

-- ## EXERCISES:

-- TODO: Show that a map œÜ : n ‚Üí g‚Åø is a homomorphism from ‚Ñ§/3‚Ñ§ to C‚ÇÉ.

-- theorem mod3_hom_to_cyclic3 [Group G] (Z3 : ZMod n) (g : G) (œÜ : G ‚Üí Z3) : Homomorphism œÜ := by

-- TODO: Show that a map œÜ : n ‚Üí g‚Åø is an isomorphism from ‚Ñ§/3‚Ñ§ to C‚ÇÉ.

-- theorem mod3_iso_to_cyclic3 [Group G] (Z3 : ZMod n) (g : G) (œÜ : G ‚Üí Z3) : Isomorphism œÜ := by

-- TODO: Generalise the above: ‚Ñ§/n‚Ñ§ is isomorphic to C‚Çô, with the map being the
-- same.

-- theorem modn_iso_to_cyclicn [Group G] (Z3 : ZMod n) (g : G) (œÜ : G ‚Üí Z3) : Isomorphism œÜ := by

/- ... -/

-- ## Automorphisms


end Sheet2
